/**
 * Office Paste Width - 任务窗格入口 v9
 */

import { CONFIG, AdjustResult, createWordState, WordState } from "./types";
import { setStatus, hasOfficeContext, cmToPoints, isWithinEpsilon } from "./utils";
import {
  getBoolSetting,
  getNumberSetting,
  saveSetting,
  getFeatureSettings,
  getResizeSettings,
  isEnabled,
} from "./settings";
import { adjustSelectedWordObject, isImageShape } from "./resize/word";
import { adjustSelectedExcelShape } from "./resize/excel";
import { adjustSelectedPptShape } from "./resize/powerpoint";
import {
  initPasteBaseline,
  checkCountChange,
  handleCountIncrease,
  cancelPendingDetection,
  updateBaseline,
} from "./resize/word-paste-detector";
import {
  insertReferenceBox,
  removeReferenceBox,
  findReferenceBox,
  getReferenceBoxSize,
  REFERENCE_BOX_CONFIG,
} from "./reference-box";
import "./logger";

function getLog() {
  return (window as any)._pasteLog || {
    debug: (msg: string, data?: any) => console.debug("[粘贴模式]", msg, data ?? ""),
    info: (msg: string, data?: any) => console.info("[粘贴模式]", msg, data ?? ""),
    warn: (msg: string, data?: any) => console.warn("[粘贴模式]", msg, data ?? ""),
    error: (msg: string, data?: any) => console.error("[粘贴模式]", msg, data ?? ""),
  };
}

const pasteLog = {
  debug: (msg: string, data?: any) => getLog().debug(msg, data),
  info: (msg: string, data?: any) => getLog().info(msg, data),
  warn: (msg: string, data?: any) => getLog().warn(msg, data),
  error: (msg: string, data?: any) => getLog().error(msg, data),
};

pasteLog.info("taskpane-new 模块已加载 v9");
console.log("=== taskpane-new v9 loaded ===");

const wordState: WordState = createWordState();

const EVENT_POLLING_CONFIG = { intervalMs: 50, maxDurationMs: 2000, maxChecks: 40 };
let eventPollingTimer: number | null = null;
let eventPollingStartAt: number = 0;
let eventPollingCheckCount: number = 0;
let eventPollingStopped: boolean = false;
let refBoxPollingTimer: number | null = null;
let currentRefBoxName: string | null = null;

function getOfficeHost(): typeof Office.HostType[keyof typeof Office.HostType] | null {
  try { return Office?.context?.host ?? null; } catch { return null; }
}

async function adjustSelectedObject(): Promise<AdjustResult> {
  const host = getOfficeHost();
  if (!host) return "none";
  const settings = getResizeSettings();
  if (host === Office.HostType.Word) {
    return await Word.run(async (context) => adjustSelectedWordObject(context, settings));
  }
  if (host === Office.HostType.Excel) return await adjustSelectedExcelShape(settings);
  if (host === Office.HostType.PowerPoint) return await adjustSelectedPptShape(settings);
  return "none";
}

async function checkSelectedImageMatchesTarget(): Promise<boolean> {
  const settings = getResizeSettings();
  const targetWidthPts = cmToPoints(settings.targetWidthCm);
  const targetHeightPts = cmToPoints(settings.targetHeightCm);
  return await Word.run(async (ctx) => {
    const range = ctx.document.getSelection();
    const inlinePics = range.inlinePictures;
    inlinePics.load("items");
    const selectionShapes = (range as any).shapes;
    if (selectionShapes?.load) selectionShapes.load("items");
    await ctx.sync();
    if (selectionShapes?.items?.length >= 1) {
      const shape = selectionShapes.items[0];
      (shape as any).load(["type", "width", "height"]);
      await ctx.sync();
      if (isImageShape(shape)) {
        const w = Number((shape as any).width), h = Number((shape as any).height);
        return (!settings.applyWidth || isWithinEpsilon(w, targetWidthPts)) && (!settings.applyHeight || isWithinEpsilon(h, targetHeightPts));
      }
    }
    if (inlinePics.items?.length >= 1) {
      const pic = inlinePics.items[0];
      (pic as any).load(["width", "height"]);
      await ctx.sync();
      const w = Number((pic as any).width), h = Number((pic as any).height);
      return (!settings.applyWidth || isWithinEpsilon(w, targetWidthPts)) && (!settings.applyHeight || isWithinEpsilon(h, targetHeightPts));
    }
    return false;
  });
}

async function eventPollingTick(): Promise<void> {
  if (!hasOfficeContext()) return;
  const host = getOfficeHost();
  if (host !== Office.HostType.Word) return;
  if (!isEnabled() || eventPollingStopped) return;
  const { resizeOnPaste } = getFeatureSettings();
  if (!resizeOnPaste) return;
  const now = Date.now();
  if (now - eventPollingStartAt > EVENT_POLLING_CONFIG.maxDurationMs || eventPollingCheckCount >= EVENT_POLLING_CONFIG.maxChecks) {
    pasteLog.info("超时或达到最大次数，停止轮询");
    stopEventPolling();
    return;
  }
  eventPollingCheckCount++;
  try {
    const { inlineIncreased, shapeIncreased, inlineCount, shapeCount } = await checkCountChange();
    if (inlineIncreased || shapeIncreased) {
      const settings = getResizeSettings();
      handleCountIncrease(settings, inlineIncreased, shapeIncreased, inlineCount, shapeCount, (result, method) => {
        if (result !== "none") {
          wordState.lastAdjustAt = Date.now();
          pasteLog.info("调整成功: " + result + " [" + method + "]");
          updateBaseline(inlineCount, shapeCount);
          setStatus("已启用。目标宽度: " + settings.targetWidthCm + " cm\n已调整: " + result + "\n时间: " + new Date().toLocaleTimeString());
          stopEventPolling();
        }
      });
    } else {
      const alreadyMatches = await checkSelectedImageMatchesTarget();
      if (alreadyMatches) { pasteLog.info("图片已符合目标尺寸，停止轮询"); stopEventPolling(); return; }
    }
  } catch (e) {
    pasteLog.error("tick 出错", e);
    if (Date.now() - wordState.lastWatcherErrorAt > CONFIG.word.statusErrorThrottleMs) {
      wordState.lastWatcherErrorAt = Date.now();
      setStatus("监视器错误: " + String(e));
    }
  }
}

function startEventPolling(): void {
  const now = Date.now();
  if (eventPollingTimer !== null && !eventPollingStopped) { eventPollingStartAt = now; eventPollingCheckCount = 0; return; }
  eventPollingStartAt = now; eventPollingCheckCount = 0; eventPollingStopped = false;
  const scheduleNext = () => {
    if (eventPollingStopped) return;
    eventPollingTimer = window.setTimeout(() => {
      eventPollingTimer = null;
      if (eventPollingStopped) return;
      void (async () => {
        await eventPollingTick();
        if (!eventPollingStopped && Date.now() - eventPollingStartAt < EVENT_POLLING_CONFIG.maxDurationMs && eventPollingCheckCount < EVENT_POLLING_CONFIG.maxChecks) scheduleNext();
      })();
    }, EVENT_POLLING_CONFIG.intervalMs);
  };
  void (async () => { await eventPollingTick(); if (!eventPollingStopped && Date.now() - eventPollingStartAt < EVENT_POLLING_CONFIG.maxDurationMs && eventPollingCheckCount < EVENT_POLLING_CONFIG.maxChecks) scheduleNext(); })();
}

function stopEventPolling(): void {
  pasteLog.info("停止轮询");
  eventPollingStopped = true;
  if (eventPollingTimer !== null) { window.clearTimeout(eventPollingTimer); eventPollingTimer = null; }
  cancelPendingDetection();
}

let pasteDebounceTimer: number | null = null;

async function onSelectionChanged(): Promise<void> {
  if (!isEnabled()) return;
  const { resizeOnPaste, resizeOnSelection } = getFeatureSettings();
  const host = getOfficeHost();
  if (host === Office.HostType.Word) {
    if (!resizeOnSelection && resizeOnPaste) {
      if (!eventPollingStopped && eventPollingTimer !== null) return;
      if (pasteDebounceTimer !== null) window.clearTimeout(pasteDebounceTimer);
      pasteDebounceTimer = window.setTimeout(() => { pasteDebounceTimer = null; void checkAndStartPolling(); }, 100);
      return;
    }
    if (resizeOnSelection) {
      if (wordState.selectionDebounceTimer !== null) window.clearTimeout(wordState.selectionDebounceTimer);
      wordState.selectionDebounceTimer = window.setTimeout(() => { wordState.selectionDebounceTimer = null; void processSelectionChanged(); }, CONFIG.word.selection.debounceMs);
    }
    return;
  }
  await processSelectionChanged();
}

async function checkAndStartPolling(): Promise<void> {
  if (!eventPollingStopped && eventPollingTimer !== null) return;
  try {
    const { inlineIncreased, shapeIncreased, inlineCount, shapeCount } = await checkCountChange();
    pasteLog.info("检查结果", { inlineIncreased, shapeIncreased, inlineCount, shapeCount });
    if (inlineIncreased || shapeIncreased) { pasteLog.info("有新增图片，启动轮询"); startEventPolling(); }
    else { pasteLog.debug("没有新增图片，更新基线"); updateBaseline(inlineCount, shapeCount); }
  } catch (e) { pasteLog.error("检查出错", e); }
}

async function processSelectionChanged(): Promise<void> {
  if (!isEnabled()) return;
  const { resizeOnSelection } = getFeatureSettings();
  if (!resizeOnSelection) return;
  const now = Date.now();
  const host = getOfficeHost();
  const threshold = host === Office.HostType.Word ? CONFIG.word.selection.throttleMs : CONFIG.otherSelectionThrottleMs;
  if (now - wordState.lastAdjustAt < threshold) return;
  wordState.lastAdjustAt = now;
  const settings = getResizeSettings();
  try {
    const result = await adjustSelectedObject();
    setStatus("已启用。目标宽度: " + settings.targetWidthCm + " cm\n已调整: " + result + "\n时间: " + new Date().toLocaleTimeString());
  } catch (e) { setStatus("错误: " + String(e)); }
}

function bindUi(): void {
  const elements = {
    enabled: document.getElementById("enabled") as HTMLInputElement | null,
    resizeOnPaste: document.getElementById("resizeOnPaste") as HTMLInputElement | null,
    resizeOnSelection: document.getElementById("resizeOnSelection") as HTMLInputElement | null,
    targetWidthCm: document.getElementById("targetWidthCm") as HTMLInputElement | null,
    setHeightEnabled: document.getElementById("setHeightEnabled") as HTMLInputElement | null,
    targetHeightCm: document.getElementById("targetHeightCm") as HTMLInputElement | null,
    lockAspectRatio: document.getElementById("lockAspectRatio") as HTMLInputElement | null,
  };
  if (Object.values(elements).some((el) => !el)) return;
  const { enabled, resizeOnPaste, resizeOnSelection, targetWidthCm, setHeightEnabled, targetHeightCm, lockAspectRatio } = elements as { [K in keyof typeof elements]: HTMLInputElement };
  enabled.checked = getBoolSetting(CONFIG.keys.enabled, CONFIG.defaults.enabled);
  const feature = getFeatureSettings();
  resizeOnPaste.checked = feature.resizeOnPaste;
  resizeOnSelection.checked = feature.resizeOnSelection;
  targetWidthCm.value = String(getNumberSetting(CONFIG.keys.targetWidthCm, CONFIG.defaults.targetWidthCm));
  setHeightEnabled.checked = getBoolSetting(CONFIG.keys.setHeightEnabled, CONFIG.defaults.setHeightEnabled);
  targetHeightCm.value = String(getNumberSetting(CONFIG.keys.targetHeightCm, CONFIG.defaults.targetHeightCm));
  const updateLockAspectRatioUi = () => {
    const width = Number(targetWidthCm.value), applyWidth = Number.isFinite(width) && width > 0;
    const height = Number(targetHeightCm.value), applyHeight = setHeightEnabled.checked && Number.isFinite(height) && height > 0;
    lockAspectRatio.checked = (applyWidth && !applyHeight) || (!applyWidth && applyHeight);
  };
  updateLockAspectRatioUi();
  enabled.addEventListener("change", async () => {
    await saveSetting(CONFIG.keys.enabled, enabled.checked);
    setStatus("已保存。启用: " + enabled.checked);
    const host = getOfficeHost();
    if (host === Office.HostType.Word) { if (enabled.checked) await initPasteBaseline(); else stopEventPolling(); }
  });
  const applyMode = async (mode: "paste" | "selection") => {
    const nextPaste = mode === "paste", nextSelection = mode === "selection";
    resizeOnPaste.checked = nextPaste; resizeOnSelection.checked = nextSelection;
    await saveSetting(CONFIG.keys.resizeOnPaste, nextPaste);
    await saveSetting(CONFIG.keys.resizeOnSelection, nextSelection);
    setStatus("已保存。粘贴模式: " + nextPaste + "，选择模式: " + nextSelection);
    const host = getOfficeHost();
    if (host === Office.HostType.Word) { if (nextPaste && isEnabled()) await initPasteBaseline(); else stopEventPolling(); }
  };
  resizeOnPaste.addEventListener("change", async () => { if (!resizeOnPaste.checked) { resizeOnPaste.checked = true; return; } await applyMode("paste"); });
  resizeOnSelection.addEventListener("change", async () => { if (!resizeOnSelection.checked) { resizeOnSelection.checked = true; return; } await applyMode("selection"); });
  const onWidthChanged = async () => {
    let next = Number(targetWidthCm.value);
    if (!Number.isFinite(next) || next < 0) return;
    if (!setHeightEnabled.checked && next <= 0) { next = CONFIG.defaults.targetWidthCm; targetWidthCm.value = String(next); }
    await saveSetting(CONFIG.keys.targetWidthCm, next);
    setStatus("已保存。目标宽度: " + next + " cm");
    updateLockAspectRatioUi();
  };
  targetWidthCm.addEventListener("input", () => void onWidthChanged());
  targetWidthCm.addEventListener("change", () => void onWidthChanged());
  setHeightEnabled.addEventListener("change", async () => { await saveSetting(CONFIG.keys.setHeightEnabled, setHeightEnabled.checked); setStatus("已保存。设置高度: " + setHeightEnabled.checked); updateLockAspectRatioUi(); });
  const onHeightChanged = async () => {
    const next = Number(targetHeightCm.value);
    if (!Number.isFinite(next) || next <= 0) return;
    await saveSetting(CONFIG.keys.targetHeightCm, next);
    setStatus("已保存。目标高度: " + next + " cm");
    updateLockAspectRatioUi();
  };
  targetHeightCm.addEventListener("input", () => void onHeightChanged());
  targetHeightCm.addEventListener("change", () => void onHeightChanged());
  lockAspectRatio.disabled = true;
}

function startRefBoxPolling(): void {
  if (refBoxPollingTimer !== null) return;
  const targetWidthCm = document.getElementById("targetWidthCm") as HTMLInputElement | null;
  const targetHeightCm = document.getElementById("targetHeightCm") as HTMLInputElement | null;
  const setHeightEnabled = document.getElementById("setHeightEnabled") as HTMLInputElement | null;
  if (!targetWidthCm || !targetHeightCm || !setHeightEnabled) return;
  refBoxPollingTimer = window.setInterval(async () => {
    if (!currentRefBoxName) { stopRefBoxPolling(); return; }
    try {
      const size = await getReferenceBoxSize(currentRefBoxName);
      if (size) { targetWidthCm.value = String(size.widthCm); targetHeightCm.value = String(size.heightCm); if (!setHeightEnabled.checked) setHeightEnabled.checked = true; }
    } catch (e) { console.error("[参考框] 轮询读取尺寸失败:", e); }
  }, REFERENCE_BOX_CONFIG.pollIntervalMs);
  pasteLog.info("参考框轮询已启动");
}

function stopRefBoxPolling(): void {
  if (refBoxPollingTimer !== null) { window.clearInterval(refBoxPollingTimer); refBoxPollingTimer = null; pasteLog.info("参考框轮询已停止"); }
}

function updateRefBoxButtonState(exists: boolean): void {
  const btnInsert = document.getElementById("btnInsertRefBox") as HTMLButtonElement | null;
  const btnRemove = document.getElementById("btnRemoveRefBox") as HTMLButtonElement | null;
  if (btnInsert) btnInsert.style.display = exists ? "none" : "inline-block";
  if (btnRemove) btnRemove.style.display = exists ? "inline-block" : "none";
}

function bindRefBoxUi(): void {
  const btnApply = document.getElementById("btnApplySettings") as HTMLButtonElement | null;
  const btnInsert = document.getElementById("btnInsertRefBox") as HTMLButtonElement | null;
  const btnRemove = document.getElementById("btnRemoveRefBox") as HTMLButtonElement | null;
  const targetWidthCm = document.getElementById("targetWidthCm") as HTMLInputElement | null;
  const targetHeightCm = document.getElementById("targetHeightCm") as HTMLInputElement | null;
  const setHeightEnabled = document.getElementById("setHeightEnabled") as HTMLInputElement | null;
  if (btnApply && targetWidthCm && targetHeightCm && setHeightEnabled) {
    btnApply.addEventListener("click", async () => {
      const width = Number(targetWidthCm.value), height = Number(targetHeightCm.value);
      if (Number.isFinite(width) && width > 0) await saveSetting(CONFIG.keys.targetWidthCm, width);
      if (Number.isFinite(height) && height > 0) { await saveSetting(CONFIG.keys.targetHeightCm, height); await saveSetting(CONFIG.keys.setHeightEnabled, true); }
      setStatus("已保存。目标宽度: " + width + " cm，目标高度: " + height + " cm");
      pasteLog.info("设置已保存", { width, height });
      
      // 保存后自动移除参考框
      if (currentRefBoxName) {
        stopRefBoxPolling();
        await removeReferenceBox(currentRefBoxName);
        currentRefBoxName = null;
        updateRefBoxButtonState(false);
        pasteLog.info("参考框已自动移除");
      }
      
      setStatus(`已保存。目标宽度: ${width} cm，目标高度: ${height} cm`);
    });
  }
  if (btnInsert) {
    btnInsert.addEventListener("click", async () => {
      pasteLog.info("点击插入参考框");
      setStatus("正在插入参考框...");
      const shapeName = await insertReferenceBox();
      if (shapeName) {
        currentRefBoxName = shapeName;
        updateRefBoxButtonState(true);
        startRefBoxPolling();
        setStatus("参考框已插入。拖拽调整大小，点击「保存」保存设置。");
        pasteLog.info("参考框插入成功", { shapeName });
      } else { setStatus("插入参考框失败，请重试。"); pasteLog.error("参考框插入失败"); }
    });
  }
  if (btnRemove) {
    btnRemove.addEventListener("click", async () => {
      pasteLog.info("点击移除参考框");
      if (currentRefBoxName) {
        stopRefBoxPolling();
        const success = await removeReferenceBox(currentRefBoxName);
        if (success) pasteLog.info("参考框移除成功"); else pasteLog.warn("参考框移除可能失败");
        currentRefBoxName = null;
        updateRefBoxButtonState(false);
        setStatus("参考框已移除。设置值已保留。");
      }
    });
  }
}

async function initRefBoxState(): Promise<void> {
  try {
    const shapeName = await findReferenceBox();
    if (shapeName) { currentRefBoxName = shapeName; updateRefBoxButtonState(true); startRefBoxPolling(); pasteLog.info("检测到已存在的参考框", { shapeName }); }
    else { updateRefBoxButtonState(false); }
  } catch (e) { pasteLog.error("初始化参考框状态失败", e); updateRefBoxButtonState(false); }
}

Office.onReady(async () => {
  pasteLog.info("=== Office.onReady 启动 v9 ===");
  console.log("=== [taskpane-new] Office.onReady 启动 v9 ===");
  if (!hasOfficeContext()) { setStatus("此页面必须在 Word/Excel/PowerPoint 任务窗格中打开。"); return; }
  bindUi();
  bindRefBoxUi();
  pasteLog.info("UI 绑定完成");
  await initRefBoxState();
  const host = getOfficeHost();
  if (host === Office.HostType.Word) {
    const { resizeOnPaste } = getFeatureSettings();
    pasteLog.info("Word 初始化", { resizeOnPaste, enabled: isEnabled() });
    if (isEnabled() && resizeOnPaste) { await initPasteBaseline(); pasteLog.info("基线初始化完成"); }
  }
  Office.context.document.addHandlerAsync(
    Office.EventType.DocumentSelectionChanged,
    () => void onSelectionChanged(),
    (result: Office.AsyncResult<void>) => {
      if (result.status === Office.AsyncResultStatus.Succeeded) { pasteLog.info("SelectionChanged 事件注册成功"); setStatus("就绪。粘贴图片后将自动调整尺寸。"); }
      else { pasteLog.error("SelectionChanged 事件注册失败", result.error); setStatus("注册监听失败: " + (result.error?.message ?? String(result.error))); }
    }
  );
});

